classdef Environment < handle
    properties
        motion_space_dimension % dimension of motion space
        evader_numbers % number of evaders in the game
        pursuer_speed % pursuer speed
        evader_speeds % array of evader speeds
        target_position % position of the target
        timestep % timestep value
        captured_evaders % boolean array containing capture status of evaders
        pursuer
        evaders
    end
    methods

        function env = Environment(N, n, v, u, r, pursuer_position, evader_positions, target_position)
            env.evader_numbers = n;
            env.motion_space_dimension = N;
            env.pursuer_speed = v;
            env.evader_speeds = u;
            env.timestep = r;
            env.captured_evaders = boolean(zeros(1,env.evader_numbers));
            env.evaders = Evader.empty(env.evader_numbers,0);

            % Initialize pursuer and evader object instances 
            if ~isempty(pursuer_position)
                env.pursuer = Pursuer(pursuer_position, env.pursuer_speed);
            else
                env.pursuer = Pursuer(rand(env.motion_space_dimension,1), env.pursuer_speed);
            end
            
            if ~isempty(evader_positions)
                for i=1:env.evader_numbers
                   env.evaders(i) = Evader(evader_positions(:,i), env.evader_speeds(i), i);
                end
            else
                for i=1:env.evader_numbers
                   env.evaders(i) = Evader(rand(env.motion_space_dimension,1), env.evader_speeds(i), i);
                end
            end
            if ~isempty(target_position)
                env.target_position = target_position;
            else
                env.target_position = rand(env.motion_space_dimension,1);
            end
        end

        function update_target(env, target_position)
            sz_input = size(target_position);
            sz_output = size(env.target_position);
            if sz_input~=sz_output
                if sz_input==fliplr(sz_output)
                    env.target_position = target_position';
                else
                    error('Wrong position dimensions.')
                end
            else
                env.target_position = target_position;
            end
        end
        
        function reset(env)
            env.pursuer.updatePos(rand(env.motion_space_dimension,1));
            for i=1:env.evader_numbers
                env.evaders(i).updatePos(Evader(rand(env.motion_space_dimension,1), env.evader_speeds(i)));
            end
        end

        function update_Environment(env,pursuer_position, evader_positions, target_position)
            env.pursuer.updatePos(pursuer_position)
            for i=1:env.evader_numbers
                env.evaders(i).updatePos(evader_positions(:,i));
            end
            env.target_position = target_position;
        end
        
        function barrier_value = barrier(env)
            barriers = zeros(env.evader_numbers,1);
            for i=1:env.evader_numbers
                barriers(i) = norm(env.target_position - env.evaders(i).position) - norm(env.target_position - env.pursuer.position);
            end
            barrier_value = min(barriers);
        end

        function win = check_initialization(env,display_info)
            if barrier(env)<0
                win = false;
                if display_info
                    disp("The current initialization results in evaders winning. Please reset the environment and try again.")
                end
            else
                win = true;
                if display_info
                    disp("The current initialization results in pursuers winning. You may proceed.")
                end
            end
        end

        function evader_names = return_evader_names(env)
            evader_names = strings(1,env.evader_numbers);
            for i=1:env.evader_numbers
                env.evaders(i).name = "evader"+int2str(env.evaders(i).index);
                evader_names(i) = env.evaders(i).name;
            end
        end

        function plot_current_positions(env)
            hold on
            for i=1:env.evader_numbers
                plot(env.evaders(i).position(1), env.evaders(i).position(2), '.', 'color', 'b', 'MarkerSize', 30)
            end
            plot(env.target_position(1), env.target_position(2), '.', 'color', 'g', 'MarkerSize', 30)
            plot(env.pursuer.position(1), env.pursuer.position(2), '.', 'color', 'r', 'MarkerSize', 30)
            hold off
        end

        function evader_positions = return_evader_positions(env,evaders)
            evader_positions = zeros(env.motion_space_dimension,env.evader_numbers);
            for i=1:length(evaders)
                evader_positions(:,i) = evaders(i).position;
            end
        end

        function evader_velocities = return_evader_velocities(env,evaders)
            evader_velocities = zeros(env.motion_space_dimension,env.evader_numbers);
            for i=1:env.evader_numbers
                evader_velocities(:,i) = env.evaders(i).heading_velocity(env.pursuer.position, env.target_position);
            end
        end

        function updateTermination(env)
            env.captured_evaders = boolean(zeros(1,env.evader_numbers));
            for i=1:env.evader_numbers
                if norm(env.pursuer.position-env.evaders(i).position)<0.01
                    env.captured_evaders(i) = true;
                end
            end
        end

        function done = step(env)
            env.updateTermination();
            if ~any(~env.captured_evaders)
                done = true;
                return
            end
            evader_list = 1:env.evader_numbers; 
            pursuer_velocity = env.pursuer.heading_velocity(env.return_evader_positions(env.evaders(evader_list(~env.captured_evaders))), env.target_position, env.timestep);
            evader_velocities = env.return_evader_velocities(env.pursuer, env.evaders);
            env.pursuer.updatePos(env.pursuer.position + env.timestep*pursuer_velocity);
            for i=evader_list(~env.captured_evaders)
                env.evaders(i).updatePos(env.evaders(i).position + env.timestep*evader_velocities(:,i));
            end
            done = false;
        end


        function plot_trajectories(env)
            env.plot_current_positions()
            hold on
            done = false; t = 1;
            while ~done
                pursuer_positions_traj(:,t) = env.pursuer.position;
                for i=1:env.evader_numbers
                    evader_positions_traj(:,t,i) = env.evaders(i).position;
                end
                done = env.step();
                t = t+1;
            end
            pursuer_positions_traj(:,t) = env.pursuer.position;
            for i=1:env.evader_numbers
                evader_positions_traj(:,t,i) = env.evaders(i).position;
            end
            plot(pursuer_positions_traj(1,:),pursuer_positions_traj(2,:),'r')
            for i=1:env.evader_numbers
                plot(evader_positions_traj(1,:,i),evader_positions_traj(2,:,i),'b')
            end
            env.plot_current_positions()
        end


    end
end

% Helper function to check for collision with a circular obstacle
